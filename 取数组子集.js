/*
获取数组中所有子集（非重复）
[1, 2, 3] ==>
[
  [],
  [ '1', '2' ],
  [ '1', '3' ],
  [ '2', '3' ],
  [ '1', '2', '3' ]
]
----------------------基础公式----------------------
【排列】的定义：
    从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个不同的元素按照一定的顺序排成一列，
    叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数。
计算公式：
    A(n, m) = n(n - 1)(n - 2)...(n - m + 1) = n! / (n - m)!

【组合】的定义：
    从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。
计算公式：
    C(n, m) = A(n, m) / m! = n! / (n - m)! / m! = n! / m!(n - m)!

设：n = 3, 元素 = [1, 2, 3], 组合方式有4类，无，单元素、两两、三三。也就是 m = 0, m = 1, m = 2, m = 3
组合公式套用:
    期望8项：1, 2, 3, 12, 13, 23, 123, 空
    将变量"m"代入到 n! / m!(n - m)!
    设：m === 0，得：3! / 0!(3 - 0)! = 6 / 6 = 1
    设：m === 1，得：3! / 1!(3 - 1)! = 6 / 2 = 3
    设：m === 2，得：3! / 2!(3 - 2)! = 6 / 2 = 3
    设：m === 3，得：3! / 3!(3 - 3)! = 6 / 6 = 1
    因此，[1, 2, 3]的全方式组合的总数是8，正好是2的3次方，推算出全组合为【2的n次方】。

以上，结果是无序组合，如果想要有序组合，则需要通过排列公式套用，
排列公式套用:
    期望16项：1, 2, 3, 12, 21, 13, 31, 23, 32, 123, 132, 213, 231, 312, 321, 空
    设：m === 0，得：3! / (3 - 0)! = 6 / 6 = 1
    设：m === 1，得：3! / (3 - 1)! = 6 / 2 = 3
    设：m === 2，得：3! / (3 - 2)! = 6 / 1 = 6
    设：m === 3，得：3! / (3 - 3)! = 6 / 1 = 6

【注】：0和1的阶乘都是1。0! === 1, 1! === 1。

----------------------解题----------------------
由上述公式推导，无序（在本题中体现为非重）组合就是本题求解的数组子集。
设：arr = [1, 2, 3], 组合方式 m = 0, m = 1, m = 2, m = 3。
期：[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]。
断言：自由组合的子集个数为2的arr.length个数，即设 subSetsLen = Math.pow(2, arr.length)
巧技：有个规律，因为子集长度为8，所以子集的下标为0 - 7，而0 - 7的二进制为000 - 111；
    而这些二进制位数正好与arr的长度一样，通过二进制的位运算表示每一项的状态。
    元数据：1, 2, 3
    下标：  0, 1, 2
    二进制：0, 0, 0
           0, 0, 1
           0, 1, 0
           0, 1, 1
           1, 0, 0
           1, 0, 1,
           1, 1, 0
           1, 1, 1
    当，二进制等于101的时候子集便是[1,3]。
    所以我们可以循环0 - 7，并取二进制当前位为1的项下标。
*/

// 理解版
Array.prototype.subs = function () {
    const len = this.length;
    const subsLen = Math.pow(2, len);
    const subSets = [];
    for(let i = 0; i < subsLen; i++) {
        const subSet = [];
        const b = _fill(i.toString(2), len);
        for(let j = 0; j < b.length; j++) {
            const flag = b[j];
            if (flag === '1') {
                subSet.push(this[j]);
            }
        }
        subSets.push(subSet);
    }
    return subSets;
    function _fill(str, len) {
        const differ = len - str.length;
        if (differ > 0) {
            for (let i = 0; i < differ; i++) {
                str = `0${str}`;
            }
        }
        return str;
    }
};
console.log([1, 2, 3].subs());

/*
优化版
循环len, j取值为0, 1, 2
i & 1 << j，没理解，但是好使o(╥﹏╥)o
*/
Array.prototype.subs = function () {
    const len = this.length;
    const subsLen = Math.pow(2, len);
    const subSets = [];
    for(let i = 0; i < subsLen; i++) {
        const subSet = [];
        for(let j = 0; j < len; j++) {
            if (i & (1 << j)) {
                subSet.push(this[j]);
            }
        }
        subSets.push(subSet);
    }
    return subSets;
};
console.log([1, 2, 3].subs());
